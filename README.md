π“ ν¬μΈνΈ μ„λΉ„μ¤ λ™μ‹μ„± λ° νΈλμ­μ… μ μ–΄ λ¶„μ„
μ΄ λ¬Έμ„λ” TDD(Test-Driven Development) λ°©μ‹μΌλ΅ κ°λ°λ ν¬μΈνΈ μ„λΉ„μ¤μ λ™μ‹μ„±(Concurrency) λ° νΈλμ­μ…(Transaction) μ μ–΄ λ°©μ‹μ— λ€ν• μƒμ„Έ λ¶„μ„κ³Ό κ΄€λ ¨ ν†µν•© ν…μ¤νΈ μ½”λ“μ— λ€ν•΄ μ„¤λ…ν•©λ‹λ‹¤.

1. κ°μ” λ° λ©ν‘
   κ°λ° μ¤‘μΈ ν¬μΈνΈ μ„λΉ„μ¤λ” μ‚¬μ©μλ“¤μ ν¬μΈνΈ μ¶©μ „ λ° μ‚¬μ© μ”μ²­μ„ μ²λ¦¬ν•©λ‹λ‹¤. νΉν μ—¬λ¬ μ‚¬μ©μκ°€ λ™μ‹μ— ν¬μΈνΈ κ΄€λ ¨ μ‘μ—…μ„ μν–‰ν•κ±°λ‚, λ‹¨μΌ μ‚¬μ©μμ— λ€ν•΄ μ—¬λ¬ μ”μ²­μ΄ λ™μ‹μ— λ°μƒν•  μ μλ” λ™μ‹μ„± ν™κ²½μ—μ„μ μ •ν™•μ„±κ³Ό μ‹ λΆ°μ„± λ³΄μ¥μ΄ μ¤‘μ”ν•©λ‹λ‹¤.

μ£Όμ” λ©ν‘λ” λ‹¤μκ³Ό κ°™μµλ‹λ‹¤:

μ •ν™•ν• ν¬μΈνΈ κ³„μ‚°: λ™μ‹μ„± ν™κ²½μ—μ„λ„ μµμΆ… ν¬μΈνΈ μ”κ³ κ°€ ν•­μƒ μμƒ κ°’κ³Ό μΌμΉν•΄μ•Ό ν•©λ‹λ‹¤.
νΈλμ­μ…μ μ›μμ„±(Atomicity): ν¬μΈνΈ μ¶©μ „/μ‚¬μ© μ‘μ—…μ€ νΈλμ­μ…μΌλ΅ λ¬¶μ—¬μ•Ό ν•λ©°, μ¤‘κ°„μ— μ¤λ¥κ°€ λ°μƒν•λ©΄ λ¨λ“  λ³€κ²½ μ‚¬ν•­μ΄ λ΅¤λ°±λμ–΄μ•Ό ν•©λ‹λ‹¤.
νΈλμ­μ…μ κ²©λ¦¬μ„±(Isolation): ν• νΈλμ­μ…μ μ‹¤ν¨ λ° λ΅¤λ°±μ΄ λ™μ‹μ— μ§„ν–‰λλ” λ‹¤λ¥Έ νΈλμ­μ…μ μ„±κ³µμ— μν–¥μ„ μ£Όμ§€ μ•μ•„μ•Ό ν•©λ‹λ‹¤.
2. λ™μ‹μ„± μ μ–΄ ν•µμ‹¬ μ „λµ
   ν¬μΈνΈ μ„λΉ„μ¤μ λ™μ‹μ„± λ° νΈλμ­μ… μ μ–΄λ¥Ό μ„ν•΄ λ‹¤μκ³Ό κ°™μ€ μ „λµκ³Ό κΈ°μ μ΄ μ μ©λμ—μµλ‹λ‹¤.

2.1. UserPointTableμ μ›μμ  μ—…λ°μ΄νΈ (AtomicInteger / μΈλ©”λ¨λ¦¬ DB)
ν¬μΈνΈ μ„λΉ„μ¤λ” UserPointTableμ΄λΌλ” μΈλ©”λ¨λ¦¬ λ°μ΄ν„°λ² μ΄μ¤λ¥Ό μ‚¬μ©ν•μ—¬ μ‚¬μ©μλ³„ ν¬μΈνΈλ¥Ό κ΄€λ¦¬ν•©λ‹λ‹¤. λ™μ‹μ„± ν™κ²½μ—μ„ μ—¬λ¬ μ¤λ λ“κ°€ λ™μ‹μ— νΉμ • μ‚¬μ©μμ ν¬μΈνΈλ¥Ό μ—…λ°μ΄νΈν•  λ• λ°μ΄ν„° μΌκ΄€μ„±μ„ λ³΄μ¥ν•κΈ° μ„ν•΄ λ‹¤μκ³Ό κ°™μ€ λ°©λ²•μ„ μ‚¬μ©ν•©λ‹λ‹¤.

ConcurrentHashMap: μ—¬λ¬ μ¤λ λ“κ°€ λ™μ‹μ— μ ‘κ·Όν•μ—¬ μ½κ³  μ“Έ μ μλ” μ¤λ λ“ μ•μ „ν• Map κµ¬ν„μ²΄μ…λ‹λ‹¤. μ‚¬μ©μ ID(Long)λ¥Ό ν‚¤λ΅ μ‚¬μ©ν•©λ‹λ‹¤.
AtomicInteger: κ° μ‚¬μ©μ ν¬μΈνΈ μ”κ³ λ¥Ό μ €μ¥ν•λ” λ° AtomicInteger (λλ” AtomicLong)λ¥Ό μ‚¬μ©ν•©λ‹λ‹¤. Atomic μ ‘λ‘μ‚¬κ°€ λ¶™μ€ ν΄λμ¤λ“¤μ€ λ‚΄λ¶€μ μΌλ΅ CAS(Compare-And-Swap) μ—°μ‚°κ³Ό κ°™μ€ ν•λ“μ›¨μ–΄ μ§€μ› μ›μ‹ μ—°μ‚°μ„ ν™μ©ν•μ—¬ λ½(Lock) μ—†μ΄λ„ μ¤λ λ“ μ•μ „ν• μ—°μ‚°(μ: incrementAndGet(), addAndGet())μ„ μν–‰ν•  μ μλ„λ΅ ν•©λ‹λ‹¤. μ΄λ¥Ό **λΉ„κ΄€μ  λ½(Pessimistic Lock)**μ΄λ‚ **λ‚™κ΄€μ  λ½(Optimistic Lock)**κ³Ό κ°™μ€ λ³µμ΅ν• λ™κΈ°ν™” λ©”μ»¤λ‹μ¦ μ—†μ΄λ„ μ›μμ„±μ„ λ³΄μ¥ν•λ” λ΅ ν”„λ¦¬(Lock-Free) λ°©μ‹μΌλ΅ λ³Ό μ μμµλ‹λ‹¤.

      Java

      // UserPointTable λ‚΄λ¶€ (μμ‹)
      public class UserPointTable {
      private final Map<Long, UserPoint> table = new ConcurrentHashMap<>();
      
          public UserPoint insertOrUpdate(long userId, long amount) {
              // compute λ©”μ„λ“λ¥Ό μ‚¬μ©ν•μ—¬ ν•΄λ‹Ή userIdμ— λ€ν• μ—…λ°μ΄νΈλ¥Ό μ›μμ μΌλ΅ μν–‰
              return table.compute(userId, (key, existingUserPoint) -> {
                  long newPoint = (existingUserPoint != null) ? existingUserPoint.point() + amount : amount;
                  // μƒλ΅μ΄ UserPoint μΈμ¤ν„΄μ¤λ¥Ό μƒμ„±ν•μ—¬ λ°ν™ (λ¶λ³€μ„± μ μ§€)
                  return new UserPoint(userId, newPoint, System.currentTimeMillis());
              });
          }
      }
      // UserPoint ν΄λμ¤ (μμ‹)
      PointServiceμ νΈλμ­μ… κ΄€λ¦¬:
      PointServiceλ” UserPointTableμ μ €μμ¤€ λ™μ‹μ„± μ μ–΄μ™€λ” λ³„κ°λ΅, μ—¬λ¬ λ°μ΄ν„° μ΅°μ‘(UserPointTable μ—…λ°μ΄νΈ, PointHistoryTable κΈ°λ΅)μ— κ±Έμ³ μ›μμ„±μ„ λ³΄μ¥ν•λ” νΈλμ­μ… λ΅μ§μ„ ν¬ν•¨ν•©λ‹λ‹¤. μ΄λ” μ‹¤μ  μ΄μ ν™κ²½μ λ°μ΄ν„°λ² μ΄μ¤ νΈλμ­μ…κ³Ό μ μ‚¬ν•κ², μ¤‘κ°„μ— μμ™Έ λ°μƒ μ‹ λ¨λ“  λ³€κ²½ μ‚¬ν•­μ΄ λ΅¤λ°±λλ„λ΅ κµ¬ν„λ©λ‹λ‹¤.

2.2. ExecutorServiceμ™€ CountDownLatchλ¥Ό ν™μ©ν• λ™μ‹μ„± ν…μ¤νΈ
ν†µν•© ν…μ¤νΈμ—μ„λ” μ‹¤μ  λ™μ‹μ„± ν™κ²½μ„ λ¨λ°©ν•μ—¬ μ„λΉ„μ¤μ κ²¬κ³ μ„±μ„ κ²€μ¦ν•©λ‹λ‹¤.

ExecutorService: μ—¬λ¬ μ¤λ λ“λ¥Ό μƒμ„±ν•κ³  κ΄€λ¦¬ν•λ©°, λΉ„λ™κΈ° μ‘μ—…μ„ λ³‘λ ¬λ΅ μ‹¤ν–‰ν•λ” λ° μ‚¬μ©λ©λ‹λ‹¤. Executors.newFixedThreadPoolμ„ ν†µν•΄ κ³ μ •λ μμ μ¤λ λ“ ν’€μ„ μƒμ„±ν•μ—¬ μ¤λ λ“ λ¦¬μ†μ¤λ¥Ό ν¨μ¨μ μΌλ΅ κ΄€λ¦¬ν•©λ‹λ‹¤.
CountDownLatch: λ¨λ“  μ¤λ λ“κ°€ νΉμ • μ‹μ κΉμ§€ λ€κΈ°ν–λ‹¤κ°€ λ™μ‹μ— μ‘μ—…μ„ μ‹μ‘ν•λ„λ΅ ν•λ” λ™κΈ°ν™” λ„κµ¬μ…λ‹λ‹¤. μ΄λ¥Ό ν†µν•΄ μ‹¤μ  λ™μ‹μ„± μƒν™©(Race Condition)μ„ μ •ν™•ν•κ² μ¬ν„ν•κ³  ν…μ¤νΈν•  μ μμµλ‹λ‹¤.
λ¨λ“  μ‘μ—…(Callable)μ΄ startLatch.await()λ¥Ό νΈμ¶ν•λ©° μ‹μ‘μ„ λ€κΈ°ν•©λ‹λ‹¤.
λ©”μΈ μ¤λ λ“μ—μ„ startLatch.countDown()μ„ νΈμ¶ν•λ©΄, λ€κΈ° μ¤‘μ΄λ λ¨λ“  μ¤λ λ“κ°€ λ™μ‹μ— μ‹¤ν–‰μ„ μ‹μ‘ν•©λ‹λ‹¤.
3. ν†µν•© ν…μ¤νΈ μΌ€μ΄μ¤ λ¶„μ„
   λ‘ κ°€μ§€ ν•µμ‹¬ ν†µν•© ν…μ¤νΈλ¥Ό ν†µν•΄ λ™μ‹μ„± λ° νΈλμ­μ… μ μ–΄μ μ ν¨μ„±μ„ κ²€μ¦ν•©λ‹λ‹¤.

3.1. testConcurrentChargesForMultipleUsers (λ‹¤μ¤‘ μ‚¬μ©μ λ™μ‹ μ¶©μ „ ν…μ¤νΈ)
λ©ν‘: μ—¬λ¬ μ‚¬μ©μκ°€ λ™μ‹μ— μ¶©μ „ μ”μ²­μ„ λ³΄λ‚Ό λ•, κ° μ‚¬μ©μμ μµμΆ… μ”κ³ κ°€ μ •ν™•ν•κ² κ³„μ‚°λλ”μ§€ ν™•μΈν•©λ‹λ‹¤.

μ‹λ‚λ¦¬μ¤:

μ—¬λ¬ λ…μ μ‚¬μ©μ(numberOfUsers)λ¥Ό μ„¤μ •ν•κ³  κ° μ‚¬μ©μμ μ΄κΈ° μ”κ³ λ¥Ό 0μΌλ΅ μ„¤μ •ν•©λ‹λ‹¤.
κ° μ‚¬μ©μμ—κ² μ—¬λ¬ κ°μ μ¶©μ „ μ”μ²­(threadCount)μ„ λ™μ‹μ— λ³΄λƒ…λ‹λ‹¤.
λ¨λ“  μ”μ²­μ΄ μ™„λ£λ ν›„, κ° μ‚¬μ©μμ μµμΆ… μ”κ³ κ°€ (μ΄κΈ° μ”κ³ ) + (μ¶©μ „ κΈμ•΅ * μ”μ²­ μ)μ™€ μΌμΉν•λ”μ§€ κ²€μ¦ν•©λ‹λ‹¤.
μ΄ κ³Όμ •μ—μ„ μμƒμΉ λ»ν• μμ™Έ(μ: IllegalArgumentException λ“±)κ°€ λ°μƒν•μ§€ μ•μ•λ”μ§€ userUnexpectedExceptionCounts λ§µμ„ ν†µν•΄ μ¶”μ ν•κ³  κ²€μ¦ν•©λ‹λ‹¤.
ν•µμ‹¬ κ²€μ¦:

assertEquals(expectedPoint, result.point(), "μ‚¬μ©μ Nμ μ”κ³ κ°€ μλ»λμ—μµλ‹λ‹¤.");
assertEquals(0, actualUnexpectedExceptionCount, "μ‚¬μ©μ Nμ μ¶©μ „ μ‘μ—… μ¤‘ μμƒμΉ λ»ν• μμ™Έκ°€ λ°μƒν–μµλ‹λ‹¤.");
κ²°κ³Ό: μ΄ ν…μ¤νΈλ” μ‹μ¤ν…μ΄ λ‹¤μ¤‘ μ‚¬μ©μ ν™κ²½μ—μ„ λ™μ‹μ— λ°μƒν•λ” μ¶©μ „ μ”μ²­λ“¤μ„ μ •ν™•ν•κ³  μ•μ „ν•κ² μ²λ¦¬ν•μ—¬, μµμΆ… μ”κ³ μ μΌκ΄€μ„±μ„ μ μ§€ν•λ”μ§€ κ²€μ¦ν•©λ‹λ‹¤.

3.2. testConcurrentRollbackWithOtherSuccesses (λ™μ‹μ„± ν™κ²½ λ΅¤λ°± κ²€μ¦ ν…μ¤νΈ)
λ©ν‘: λ™μ‹μ„± ν™κ²½μ—μ„ νΉμ • μ”μ²­μ΄ μ‹¤ν¨ν•μ—¬ νΈλμ­μ… λ΅¤λ°±μ΄ λ°μƒν•λ”λΌλ„, λ™μ‹μ— μ‹¤ν–‰λ λ‹¤λ¥Έ μ„±κ³µμ μΈ μ”μ²­λ“¤μ΄ μ¬λ°”λ¥΄κ² μ²λ¦¬λκ³  μµμΆ… μ”κ³ μ— μν–¥μ„ λ―ΈμΉμ§€ μ•λ”μ§€ ν™•μΈν•©λ‹λ‹¤. μ΄λ” νΈλμ­μ…μ κ²©λ¦¬μ„±κ³Ό μ›μμ„±μ„ κ²€μ¦ν•λ” λ° μ¤‘μ”ν•©λ‹λ‹¤.

μ‹λ‚λ¦¬μ¤:

νΉμ • μ‚¬μ©μ(userId)μ—κ² 0μΌλ΅ μ΄κΈ° μ”κ³ λ¥Ό μ„¤μ •ν•©λ‹λ‹¤.
μ—¬λ¬ κ°μ μ„±κ³µμ μΈ μ¶©μ „ μ”μ²­κ³Ό ν•λ‚μ μ‹¤ν¨λ¥Ό μ λ„ν•λ” μ”μ²­ (μ: μμ κΈμ•΅ μ¶©μ „)μ„ λ™μ‹μ— λ³΄λƒ…λ‹λ‹¤.
μ‹¤ν¨λ¥Ό μ λ„ν•λ” μ”μ²­μ€ IllegalArgumentExceptionκ³Ό κ°™μ€ μμ™Έλ¥Ό λ°μƒμ‹μΌ PointService λ‚΄μ νΈλμ­μ… λ΅¤λ°±μ„ μ λ„ν•©λ‹λ‹¤.
λ¨λ“  μ”μ²­μ΄ μ™„λ£λ ν›„, μµμΆ… μ”κ³ κ°€ (μ΄κΈ° μ”κ³ ) + (μ„±κ³µμ μΈ μ¶©μ „ μ”μ²­ μ * κ° μ¶©μ „ κΈμ•΅)κ³Ό μ •ν™•ν μΌμΉν•λ”μ§€ κ²€μ¦ν•©λ‹λ‹¤. μ‹¤ν¨λ΅ μΈν•΄ λ΅¤λ°±λ μ”μ²­μ€ μµμΆ… μ”κ³ μ— λ°μλμ§€ μ•μ•„μ•Ό ν•©λ‹λ‹¤.
AtomicIntegerλ¥Ό μ‚¬μ©ν•μ—¬ μ‹¤ν¨ μ”μ²­κ³Ό μ„±κ³µ μ”μ²­μ΄ κ°κ° μμƒ νμλ§νΌ λ°μƒν–λ”μ§€ μΉ΄μ΄νΈν•κ³  κ²€μ¦ν•©λ‹λ‹¤.

ν•µμ‹¬ κ²€μ¦: fail 

"charge() λ©”μ†λ“κ°€ μ ν¨ν•μ§€ μ•μ€ κΈμ•΅μ— λ€ν•΄ μμƒλ μμ™Έλ¥Ό λμ§€μ§€ μ•κ³  μ„±κ³µν–μµλ‹λ‹¤."); 
(μ‹¤ν¨ μ”μ²­μ΄ μ‹¤μ λ΅ μμ™Έλ¥Ό λμ§€λ”μ§€ ν™•μΈ)

assertEquals(expectedFinalBalance, finalUserPoint.point(), "λ™μ‹μ„± ν™κ²½μ—μ„ μ‹¤ν¨ μ”μ²­μ΄ λ΅¤λ°±λ ν›„ μµμΆ… μ”κ³ κ°€ μμƒκ³Ό λ‹¤λ¦…λ‹λ‹¤.");  
(λ΅¤λ°±μ΄ λ‹¤λ¥Έ μ„±κ³µ μ”μ²­μ— μν–¥μ„ λ―ΈμΉμ§€ μ•λ”μ§€ ν™•μΈ)

assertEquals(1, failedOperationCount.get(), "μ‹¤ν¨λ¥Ό μ λ„ν•λ” μ”μ²­μ΄ μ •ν™•ν ν• λ² λ°μƒν•΄μ•Ό ν•©λ‹λ‹¤.");   

assertEquals(numberOfSuccessCharges, successfulOperationCount.get(), "λ¨λ“  μ„±κ³µ μ”μ²­μ΄ μ •μƒμ μΌλ΅ μ²λ¦¬λμ–΄μ•Ό ν•©λ‹λ‹¤.");   

κ²°κ³Ό: μ΄ ν…μ¤νΈλ” μ‹μ¤ν…μ΄ λ³µμ΅ν• λ™μ‹μ„± μ‹λ‚λ¦¬μ¤μ—μ„λ„ νΈλμ­μ…μ **μ›μμ„±(Atomicity)**κ³Ό **κ²©λ¦¬μ„±(Isolation)**μ„ ν¨κ³Όμ μΌλ΅ λ³΄μ¥ν•μ—¬, μ‹¤ν¨ν• μ‘μ—…μ΄ μ „μ²΄ μ‹μ¤ν…μ μΌκ΄€μ„±μ„ ν•΄μΉμ§€ μ•μμ„ μ…μ¦ν•©λ‹λ‹¤. λ΅κ·Έλ¥Ό ν†µν•΄ μ„±κ³µμ μΈ μ¶©μ „κ³Ό λ΅¤λ°±λλ” μ‹¤ν¨κ°€ λ™μ‹μ— λ°μƒν•κ³  μµμΆ… μ”κ³ κ°€ μ •ν™•ν κ³„μ‚°λλ” κ²ƒμ„ ν™•μΈν–μµλ‹λ‹¤.

4. κ²°λ΅ 
   μ μ‹λ λ™μ‹μ„± μ μ–΄ μ „λµκ³Ό ν†µν•© ν…μ¤νΈλ” ν¬μΈνΈ μ„λΉ„μ¤κ°€ λ‹¤μ¤‘ μ‚¬μ©μ λ° λ™μ‹μ„± ν™κ²½μ—μ„ ν¬μΈνΈ μ”κ³ μ μΌκ΄€μ„±, νΈλμ­μ…μ μ›μμ„± λ° κ²©λ¦¬μ„±μ„ ν¨κ³Όμ μΌλ΅ λ³΄μ¥ν•κ³  μμμ„ λ³΄μ—¬μ¤λ‹λ‹¤. νΉν, ConcurrentHashMapκ³Ό κ°™μ€ μ¤λ λ“ μ•μ „ν• μλ£κµ¬μ΅°μ™€ ExecutorService, CountDownLatchλ¥Ό ν™μ©ν• ν…μ¤νΈ μ „λµμ€ λ³µμ΅ν• λ™μ‹μ„± λ¬Έμ λ¥Ό κ²€μ¦ν•λ” λ° λ§¤μ° μ μ©ν•©λ‹λ‹¤.